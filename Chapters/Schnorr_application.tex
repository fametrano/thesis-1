\chapter{Schnorr's applications}
\label{chpr:application}
In this chapter we will present some of the applications that Schnorr would make deployable in Bitcoin: mostly they are intended to adapt utilities already present in Bitcoin, such as multi-signatures and threshold signatures. Then we will give a look to adaptor signatures, a tool that would enable better implementations of layer two solution and cross-chain atomic swaps.

\bigskip

\section{Multi-signature: MuSig ($\mu \Sigma$)}
Usually Schnorr is presented with an implicit multi-signature scheme: given $n$ users that want to sign a single message $m$, they can sign it on their own, the final signature being the sum of the so called partial signatures. This signature can then be verified against the sum of the public keys.
\\
Let's study it through an example: Alice and Bob have the key pairs $(q_A, Q_A)$ and $(q_B, Q_B)$, respectively. If both participants are honest, they will proceed as follows: they exchange their public keys, computing the aggregated one $Q = Q_A + Q_B$. Then each one of them proceed as usual, producing $K_A$ and $K_B$ and defining $K = K_A + K_B$, after having exchanged also the public nonces. The signature would then be $(K, s)$, with $s = s_A + s_B = k_A + \text{hash}(K \ || \ Q \ || \ m)q_A + k_B + \text{hash}(K \ || \ Q \ || \ m)q_B \ (\text{mod} \ n)= (k_A + k_B) + \text{hash}(K \ || \ Q \ || \ m)(q_A + q_B) \ (\text{mod} \ n)$. Verification would require: $sG = K + \text{hash}(K \ || \ Q \ || \ m)Q$, just as usual. Third parties would not be able to recognize that this is indeed a multi-signature.
\\
This sounds great, except for the fact that it is a completely insecure scheme: we assumed that both the participants were honest, a deadly hypothesis for every cryptosystem. Imagine that it is Bob that wants to cheat. He could simply says that his public key is $Q_B' = Q_B - Q_A$. Then, if someone sends money to the address associated to $Q = Q_A + Q_B' = Q_A + Q_B - Q_A = Q_B$, clearly Bob can control the funds by himself, being in possess of the associated private key.
\\
This kind of attack is called rogue key attack and is a serious concern for multi-signature schemes: given $n$ participants, a subset of $1 \leq t < n$ dishonest signers use public keys that are functions of the public keys of honest signers, allowing them to forge a signature without the aid of the honest signers for the whole set of public keys. There are certain ways to prevent such an attack: for example by ensuring that the participants own the private keys associated with the alleged public keys (now it is not possible for Bob to cheat, since it would imply breaking the ECDLP), a setting that takes the name of KOSK (knowledge of secret key). 

\bigskip
\noindent
In this section we will present a provably secure multi-signature scheme of the type $n$-of-$n$. But before delving into its technicalities, it could be better to stop and talk a little about how changes are introduced in Bitcoin: deploying innovations in Bitcoin is a long procedure, due to its decentralized consensus protocol. Since it could require years to take a new feature to it, we should think about properties that would enhance Bitcoin in the long term. Today Bitcoin is missing some important properties in order to be a good method of payment: it is missing both fungibility\footnote{Fungibility is the property of a good whose individual units are interchangeable.} and privacy. It is missing fungibility due to the fact that it is missing privacy: Bitcoin is pseudonymous, not anonymous, in the sense that an address is not directly linked to a physical person, but every single transaction is on the public  ledger open to (possibly) every node in the network. Low privacy means that bitcoins, not being interchangeable, could be treated differently: think about the bitcoins possessed by the creator of Bitcoin, Satoshi Nakamoto, and not moved since the creation of Bitcoin. Obviously they have not the same appeal of newly minted coins.
\\
Fortunately enough, the lack of some properties is not everlasting: for such a reason, when introducing a new feature in Bitcoin we should try to fix these problems. So, we will give now a look to some properties that, in a long term view, a new multi-signature scheme should possess:
\begin{enumerate}
	\item Accountability: this property refers to $m$-of-$n$ multi-signature schemes (also referred to as threshold schemes) and deals with the fact that for the participants of the scheme should be possible to know who signed and to show to others that they have not;
	\item Usability: the ease of use is important. If an interactive scheme requires a huge number of rounds, it won't be used by anyone;
	\item Privacy: third parties should learn as little about the policy of the scheme as possible (particular kind of policies could identify your transactions, leading to various problems, like censorship by miners).
\end{enumerate}

\bigskip
\noindent
After having discussed partially the reasons behind its creation, we present now the MuSig scheme \cite{RefWork:11}. MuSig is an interactive (meaning that the scheme comprehends different rounds of communication between the participants) multi-signature scheme, based on Schnorr signature. MuSig has some very attractive properties, namely:
\begin{itemize}
	\item The size of the signature is equal to the single user case;
	\item It is provably secure in the plain public key model\footnote{The signers are only required to have a public key: they do not have to prove ownership of it, i.e. knowledge of the associated private key.};
\end{itemize}
These properties, although being appealing, are not original: MuSig shares them with others scheme, in particular with the Bellare-Neven (BN) scheme \cite{RefWork:10}. The novelty introduced by the authors is that they recovered key aggregation, meaning that to the scheme can be associated a unique joint public key, leading to a verification algorithm that is equal to the single user case: the multi-signature can be verified with respect to a single aggregated public key, leading to greater privacy. 
\\
The Bellare-Neven scheme prevents rogue key attacks relying on a particular algorithm to compute the partial signatures, avoiding a trusted setup: each participant $i \in \{1, ..., n\}$ computes $s_i = k_i + c_iq_i, \ c_i = \text{hash}(\langle L \rangle\ || \ Q_i \ || \ K \ || \ m)$, where $K = \sum_{i = 1}^{n}K_i$, $m$ is the message to be signed, $Q_i = q_iG$ the public keys and $\langle L \rangle$ a unique encoding of the multiset of public keys $L = \{Q_1, Q_2, ..., Q_n\}$. The verification equation then becomes: $sG = K + \sum_{i = 1}^{n}c_iQ_i, \ s = \sum_{i = 1}^{n}s_i$. We can clearly notice that a validator needs the whole set of public keys in order to check the signature. 
\\
We can think about MuSig as a variant of BN that recovers key aggregation. The setting in which the two schemes are defined is the same: both can be proven to be secure in the plain public key model under the discrete logarithm assumption\footnote{The discrete logarithm assumption requires the DL to be hard on the selected group. This means that if the DL is hard, then the scheme is secure.}, modeling the hash functions involved as a public random oracle.
\\
Security is to be intended in the sense that it is infeasible for an adversary to forge multi-signatures involving at least an honest participant, that is: the adversary is not able to produce on its own a signature valid for the set of public keys containing the one of the honest signer.
\\
We stress the fact that, from the applicative point of view, key aggregation is a fundamental property: if the scheme is usable (few interaction rounds), then we get for free privacy and accountability (MuSig is an $n$-of-$n$ scheme, so that it is possible to generate a valid signature only if all the participants agree). Indeed, thanks to key aggregation, verifiers will only see an aggregated public key: they wouldn't even know that it is indeed aggregate, since it is indistinguishable from a normal public key. This is also important from the point of view of efficiency: in Bitcoin every single node has the possibility of validating each transaction, meaning that verification efficiency and signature size are very important, more than the timing of the signing algorithm. This is why, although there are multisig schemes with fewer interaction rounds, MuSig is generally preferred: the benefits of key aggregation are improved bandwidth (no need for communication of multiple public keys), privacy (aggregated public key indistinguishable from a normal one) and validation efficiency (as efficient as a normal Schnorr's verification, slightly faster than the ECDSA case).
\\
Moreover if the aggregated public key is not given to the verifier, it is still possible to recover it just from the set of public keys of the participant, without interaction with the signers.

\bigskip
\noindent
The plain public key setting plays a crucial role when trying to enable multi-signatures across multiple inputs of a Bitcoin transaction, resulting in a unique signature per transaction.  In case the transaction spends inputs from different owners, they will obviously need to collaborate to produce the multi-signature. Such a construction would reduce further the traffic on-chain, resulting in a benefit for all the network participants. Such a change would require the introduction of new opcodes in the Bitcoin scripting language, but this can be done via a soft fork (i.e. in a backward compatible way). To see why the plain public key model is fundamental to enable cross-input multi-signature, think about an attacker that identifies some outputs he want to steal, corresponding to a set $\{Q_1, Q_2, ..., Q_{n - t}\}$ of public keys. He could try to identify another set of keys $\{Q_{n - t + 1}, ..., Q_n\}$ such that he can sign for the aggregated public key. He would be able to steal the coins just by sending a small amount of his own moneys to outputs corresponding to the keys he found and finally creating a transaction with inputs the outputs he want to steal and the newly created outputs in his possession: by construction he is able to forge a signature on his own for this transaction. But the plain public key model defends exactly against such a situation, since the game is won by the adversary if he is able to forge a signature over a set of keys that includes at least one key not in possession of the attacker. 
\\
We have talked about cross-input aggregation, that would reduce the number of signatures to one per transaction. Is it possible to go further? For example, is it possible to obtain a single signature on a block basis? Unfortunately it is not possible through Schnorr, since as we will see the aggregation scheme, to be secure, has to be done interactively: this obviously prevents aggregation on a block level. However the discussion would not be fair if we would not point out that changing signature scheme it would become possible: for example the BLS signature scheme is non interactive when it comes to aggregation. This would enable a single signature per transaction. 

\bigskip
\noindent
Now we can finally look at the inner working of the scheme: it is parameterized by the cyclic group $\mathbb{G}$ denoted in additive notation, its order $n$, a generator of the group $G$ and three hash functions $H_{com}, \ H_{agg}$ and $H_{sign}$: $\{0, 1\}^* \to \{0, 1\}^{L_n}$. The bit length of the order $n$ is denoted by $L_n$ and assumed to be a security parameter. The key generation algorithm is not presented: we assume each participant $i \in \{1, ..., m\}$ is in possession of a proper key pair $\{q_i, Q_i\}$. The signing algorithm and the verification algorithm are presented respectively in Algorithms \ref{alg:musig_sig} and \ref{alg:musig_ver}. In the following $\langle L \rangle$ denotes a unique encoding of the multiset of public keys and the indices used in the signing algorithm are local references to the other cosigners. Moreover Algorithm \ref{alg:musig_sig} is split in interactive rounds according to the \textbf{send} and \textbf{upon reception of} commands.

\bigskip

\begin{algorithm}
	\caption{MuSig: signing algorithm}
	\label{alg:musig_sig}
	\begin{algorithmic}[1]
		\Procedure{MuSig\_sig}{$M, q_1, \{Q_2, ..., Q_m\}$}
		\State $m \gets \text{hash}(M)$
		\State $\langle L \rangle \gets \{q_1G, Q_2, ..., Q_m\}$
		\For {$i \gets 1, m$}
		\State $a_i \gets \text{int}(H_{agg}(\langle L \rangle \ || \ \text{bytes}(Q_i)))$
		\EndFor
		\State $Q \gets \sum_{i = 1}^{m}a_iQ_i$
		\State $k_1 \xleftarrow{\text{\$}} [1, ..., m - 1]$
		\State $K_1 \gets k_1G, \ t_1 \gets H_{comm}(\text{bytes}(K_1))$
		\State \textbf{send} $t_1$
		\State \textbf{upon reception of} $t_2, ..., t_m$ \textbf{send} $K_1$
		\State \textbf{upon reception of} $K_2, ..., K_m$ \textbf{do}
		\State $\ \ \ \ \ $ \textbf{for} $i \gets 2, m$ \textbf{do}
		\State $\ \ \ \ \ \ \ \ \ \ $ \textbf{if} $t_i \neq H_{comm}(\text{bytes}(K_i))$ \textbf{do}
		\State $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ $ \textbf{abort}
		\State $\ \ \ \ \ \ \ \ \ \ $ \textbf{end if}
		\State $\ \ \ \ \ $ \textbf{end for} 
		\State $K \gets \sum_{i = 1}^{m}K_i$
		\State $c \gets \text{int}(H_{sig}(\text{bytes}(Q) \ || \ \text{bytes}(K) \ || \ m))$
		\State $s_1 \gets k_1\ + ca_1q_1 \ (\text{mod} \ n)$
		\State \textbf{send} $s_1$
		\State \textbf{upon reception of} $s_2, ..., s_m$ \textbf{do}
		\State $s \gets \sum_{i = 1}^{m}s_i \ (\text{mod} \ n)$
		\State \textbf{return} $(K, s)$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\bigskip

\begin{algorithm}
	\caption{MuSig: verification algorithm}
	\label{alg:musig_ver}
	\begin{algorithmic}[1]
		\Procedure{MuSig\_ver}{$L, M, (K, s)$}
		\State $m \gets \text{hash}(M)$
		\For {$i \gets 1, m$}
		\State $a_i \gets \text{int}(H_{agg}(\langle L \rangle \ || \ \text{bytes}(Q_i)))$
		\EndFor
		\State $Q \gets \sum_{i = 1}^{m}a_iQ_i$
		\State $c \gets \text{int}(H_{sig}(\text{bytets}(Q) \ || \ \text{bytes}(K) \ || \ m))$
		\If {$sG = K + cQ$}
		\State \textbf{return True}
		\EndIf
		\State \textbf{return False}
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\bigskip
\noindent
{\bf Proof of correctness}: We have to prove that $sG = K + cQ$.
\\
$$sG = \left(\sum_{i = 1}^{m} s_i\right)G = \left(\sum_{i = 1}^{m}(k_i + ca_iq_i)\right)G = \sum_{i = 1}^{m}(k_iG + ca_iq_iG) =$$
$$= \sum_{i = 1}^{m}k_iG + \sum_{i = 1}^{n} ca_iq_iG = \sum_{i = 1}^{m}K_i + c\sum_{i  = 1}^{m}a_iQ_i = K + cQ.$$
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ $\square$

\bigskip
\noindent
For the security proof of the scheme we refer to the original paper \cite{RefWork:11}. The algorithms presented come directly from there: if implemented in Bitcoin according to the deployment of Schnorr suggested in \cite{RefWork:5} they would need to be adapted: however, since the BIP is under review by the community and far from being implemented, we do not proceed with it. 
\\
The verification algorithm is constructed getting as input the multiset of public keys $L$. To improve both efficiency and privacy it is immediate to modify it in order to take as input the aggregate key, simply by relying on the standard Schnorr verification algorithm.
\\
Dealing with ECDSA and Schnorr in chapter \ref{chpr:dss}, we have seen that in the single user setting there was the possibility to derandomize the signature algorithm without loss of security, by generating the random nonce $k$ through a deterministic function. This is done since pseudo random generation is one of the major sources of problems in cryptography. This is not anymore suggested in the multi-user setting: it is necessary to ensure to use different random values when the other signers change their $K$ values in repeated signing attempts, otherwise secret key recovery would be possible. 
\\
Here follows an example taken from \cite{RefWork:11}: assume Alice and Bob have key pairs $(q_A, Q_A)$ and $(q_B, Q_B)$, respectively. They want to jointly produce a signature. Alice generates $k_A$ and sends $K_A = k_AG$ to Bob. In a first attempt, Bob responds with $K_B$. Alice then computes:
$$K = K_A + K_B,$$
$$c = H_{sig}(Q \ || \ K \ || \ m),$$
$$s_A = k_A + ca_Aq_A \ (\text{mod} \ n),$$
and sends $s_A$ to Bob. Bob is trying to cheat on Alice, and decides not to produce a valid $s_B$, and thus the protocol fails. A new signing attempt takes place, and Alice again sends the same $K_A$. Bob responds with $K_B' \neq K_B$. Alice then computes $c' = H_{sig}(Q \ || \ K_A + K_B' \ || \ m)$ and $s_A' = k_A + c'a_Aq_A \ (\text{mod} \ n)$ and sends $s_A'$ to Bob. Now Bob is able to derive Alice's private key:
$$s_A - s_A' = (c - c')a_Aq_A \ (\text{mod} \ n) \ \Longrightarrow \ q_A = (c - c')^{-1}a_A^{-1}(s_A - s_A') \ (\text{mod} \ n).$$
To avoid this problem, each signer must ensure that whenever any $K$ value sent by other cosigners or the message $m$ changes, his $k_i$ changes as well. 

\bigskip

\bigskip

\section{Threshold signatures}
With the name threshold signatures we refer to policies of the kind $m$-of-$n$, where it is necessary that at least $m$ participants of the scheme decide to collaborate to produce a valid signature. This kind of policy is very popular in Bitcoin, since it is flexible and has many applications: for example, a single user could use such a policy to improve security, storing the keys on different machines, at the same time defeating the risk of loss of some keys. 
\\
In this section we will study a provable secure Schnorr based threshold scheme. For the security proof we refer to \cite{RefWork:14}. The scheme is constructed on top of the Pedersen Verifiable Secret Sharing Scheme (VSSS) and Pedersen's multi-party protocol to generate a random shared secret, hence we start presenting these two schemes.

\bigskip

\subsection{Verifiable secret sharing scheme}
\label{subsec:1}
Hereinafter, we will refer to threshold signature schemes as $t$-of-$m$ schemes in order to avoid confusion in the notation.
\\
Typically, in a $t$-of-$m$ secret sharing scheme, a trusted dealer distributes a secret $s$ to $m$ players $P_1, ..., P_m$ in such a way that any subgroup of at least $t$ members can recover the secret, while any subgroup of cardinality strictly less than $t$ learns nothing about it. A verifiable secret sharing scheme moreover prevents the dealer from cheating, since each participant can verify that his share of the secret is consistent with the others. The novelty introduced by Pedersen is that his scheme is non-interactive in the verification and does not require trust between the parties involved. Still there is a trusted dealer, a figure we would like to get rid of: this will be done through the second protocol we will present in Section \ref{subsec:2}. Here follows the VSSS proposed by Pedersen.

\bigskip
\noindent
Fix an elliptic curve over a prime finite field $E(\mathbb{F}_p)$, characterized by the EC domain parameters $T = (a, b, p, G, n, h)$ and fix another generator $H$ of the same cyclic group generated by $G$. We require that these two generators are "nothing up my sleeves" (NUMS), meaning that we do not know the discrete logarithm of one with respect to the other, and vice versa.
\\
Assume that the dealer has a secret value $s \in \mathbb{Z}_n$ and a number $s' \in \mathbb{Z}_n$ generated at random. He commits\footnote{A commitment scheme is a cryptographic primitive used to commit to some secret data without revealing anything about it. Commitment schemes are designed so that it is unfeasible to change the secret: when revealed in a second moment, we have probabilistic assurance that it is the real committed value. A typical example of commitment scheme is a collision resistant hash function, e.g. SHA-256.} to the couple $(s, s')$ through the so called Pedersen commitment $C_0 = sG + s'H$. The NUMS property is needed to prevent the person who commits from lying about the values he committed to. Assume indeed that the dealer knows the discrete logarithm of H with respect to G: $H = r_HG$. In this case she could write: $C_0 = sG + s'H = (s + s'r_H)G = (s \pm ar_H + s'r_H)G = (s - ar_H)G + (s'r_H + ar_H)G = (s - ar_H)G + (s' + a)H, \ \forall a \in \mathbb{Z}_n$.
\\
After having broadcasted the commitment, the secret $s$ can be shared among $P_1, ..., P_m$ through the following protocol:

\bigskip
\noindent
{\bf The dealer}:
\begin{enumerate}
	\item Chooses a couple of random polynomials of degree $t - 1$: 
	$$f(u) = s + f_1u + ... + f_{t - 1}u^{t - 1}, \ f'(u) = s' + f'_1u + ... + f'_{t - 1}u^{t - 1},$$
	where $s \ \text{and} \ s'$ are the committed values, while $f_i, f'_i \in \mathbb{Z}_n$ are randomly chosen for every $i \in \{1, ..., t - 1\}$;
	\item Computes $(s_i, s'_i) = (f(i), f'(i))$ for $i \in \{1, ..., m\}$;
	\item Sends secretly $(s_i, s'_i)$ to $P_i, \forall i \in \{1, ..., m\}$;
	\item Broadcasts the values $C_j = f_jG + f'_jH, \ \forall j \in \{1, ..., t - 1\}$.
\end{enumerate}

\bigskip

\noindent
{\bf Each participant $P_i$}:
\begin{enumerate}
	\item Verifies the consistency of its share of the secret as:
	$$s_iG + s'_iH = \sum_{j = 0}^{t - 1}i^jC_j.$$
	If this check fails he broadcasts a compliant against the dealer;
	\item For each compliant from a player $i$, the dealer defends himself by broadcasting the values $(s_i, s'_i) = (f(i), f'(i))$ that satisfies the checking equation at point 1;
	\item Aborts the protocol if:
	\begin{itemize}
		\item The dealer received more than $t$ compliants in step 1;
		\item She answered to a compliant in step 2 with values that violates again the checking equation.
	\end{itemize}
\end{enumerate}
Pedersen proved that any coalition of less than $t$ players cannot get any information about the shared secret, provided that the discrete logarithm in $E(\mathbb{F}_p)$ is hard\footnote{This is important since we are not adding cryptographic assumptions.}. For the proof we refer to the original paper \cite{RefWork:13}. Although we do not look at the proof, it may still be of interest to check why the verification procedure should succeed:
$$s_iG+ s'_iH = f(i)G + f'(i)H = \sum_{j = 0}^{t- 1}f_ji^jG + \sum_{j = 0}^{t - 1}f'_ji^jH =$$
$$ \sum_{j = 0}^{t - 1}i^j(f_jG + f'_jH)= \sum_{j = 0}^{t - 1}i^jC_j.$$
We used the convention that $f_0 = s$ and $f'_0 = s'$. Remembering that $C_0$ commits to the secret and that the other $C_j$ commits to the polynomials, we have the assurance that the dealer is not cheating. Indeed there is one and only one polynomial of degree at most $t - 1$ satisfying $f(i) = s_i$, respectively $f'(i) = s'_i$, for $t$ values of $i$. 
\\
This is also the key property that allows the reconstruction of the secret value from any group $\mathcal{P}$ of $t$ participants. Indeed the members in $\mathcal{P}$ can recover the polynomial $f$ through the Lagrange's interpolation formula, that given a set of $t$ points $(i, s_i = f(i))$ returns the lowest degree polynomial (in this case a $t - 1$ degree polynomial) that satisfies $f(i) = s_i$:
$$f(u) = \sum_{i \in \mathcal{P}}f(i)\omega_i(u), \ \text{where} \ \omega_i(u) = \prod_{j \in \mathcal{P}, \ j \neq i}\frac{u - j}{i - j} \ (\text{mod} \ n).$$
Since it holds that $s = f(0)$ by definition, the group $\mathcal{P}$ can directly reconstruct the secret as:
$$s = f(0) = \sum_{i \in \mathcal{P}}f(i)\omega_i,  \ \text{where} \ \omega_i = \omega_i(0) = \prod_{j \in \mathcal{P}, \ j \neq i}\frac{j}{j - i} \ (\text{mod} \ n).$$

\bigskip

\subsection{Protocol for the generation of a random shared secret}
\label{subsec:2}
As we pointed out before, we would like to get rid of the trusted dealer, so that it is possible to generate the key between distrustful parties. The key generation phase of the signature scheme generates a random shared secret key in a distributed way according to the following protocol:
\\
\\
{\bf Each participant $P_i$}:
\begin{enumerate}
	\item Chooses $r_i, r'_i \in \mathbb{Z}_n$ at random and verifiably shares $(r_i, r'_i)$ acting as the dealer according to the Pedersen's VSSS described above. Let the sharing polynomials of participant $i$ be $f_i(u) = \sum_{j = 0}^{t - 1}a_{ij}u^j$, $f'_i(u) = \sum_{j= 0}^{t - 1}a'_{ij}u^j$, where $a_{i0} = r_i$ and $a'_{i0} = r'_i$. The public commitments are $C_{ik} = a_{ik}G + a'_{ik}H$ for $k \in \{0, ..., t - 1\}$;
	\item Sets $H_0 = \{P_j \ | \ P_j \ \text{is not detected to be cheating at step 1}\}$. The distributed secret value $r$ is equal to $\sum_{i \in H_0}r_i$. Each participant $P_i$ sets his share of the secret at $s_i= \sum_{j \in H_0}f_j(i) \ (\text{mod} \ n)$ and set the value $s'_i = \sum_{j \in H_0}f'_j(i) \ (\text{mod} \ n)$.
	\item Each player in $H_0$ broadcasts $R_i = r_iG$ via Feldman's VSSS:
	\begin{enumerate}
		\item Each player $P_i$ in $H_0$ broadcasts $A_{ik} = a_{ik}G$ for $k \in \{0, ..., t - 1\}$;
		\item Each player $P_j$ verifies the values broadcast by the other players in $H_0$: for each $P_i \in H_0$, $P_j$ checks:
		$$f_i(j)G = \sum_{k = 0}^{t - 1} j^kA_{ik}.$$
		If the check fails for an index $i$, $P_j$ complaints against $P_i$ broadcasting the values $(f_i(j), f'_i(j))$ that satisfy the checking equation of the Pedersen's VSSS but not the one at point (b);
		\item For players $P_i$ who received at least one valid complaint, the other players run the reconstruction phase of Pedersen's VSSS to compute $r_i$, $f_i(u)$ and $A_{ik}$ for $k \in \{0, ..., t - 1\}$. All participants in $H_0$ set $R_i = r_iG$. 
	\end{enumerate} 
\end{enumerate}
After the execution of the protocol the following equations hold:
$$R = \sum_{i \in H_0} R_i = \sum_{i \in H_0}r_iG = rG,$$
$$f(u) = \sum_{i \in H_0} f_i(u) = r + a_1u + ... + a_{t - 1}u^{t - 1}, \ \text{where} \ a_i = \sum_{j \in H_0}a_{ji},$$
$$f(i) = s_i.$$
We introduce the following notation: 
$$(s_1, ..., s_n) \xleftrightarrow{\text{(t, m)}} (r|R, a_iG, H_0), \ i \in \{1, ..., t - 1\}.$$
It means that $s_j$ is the share of secret key $r$ belonging to $P_j$ for $j \in H_0$. The values $a_iG$
are the public commitments of the sharing polynomials $f(u)$ and $(r, R)$ is the key pair that can be reconstructed by any subgroup of $H_0$ composed of at least $t$ participants. 
\\
Before we pass to analyse the actual signature scheme, let's give a look at the checking equation at point (b) in the previous protocol.
$$f_i(j)G = \sum_{k = 0}^{t - 1}a_{ik}j^kG = \sum_{k = 0}^{t - 1}j^kA_{ik}.$$

\subsection{Threshold signature scheme}
Now that we have defined the primitives on which it is built, we can finally discuss the protocol that implements the $t$-of-$m$ threshold signature scheme. 

\bigskip
\noindent
{\bf Key generation}: All $m$ participants have to cooperate to generate a public key $X$ and a share of the secret key for each participant $P_j$. This can be done relying on the protocol presented in Section \ref{subsec:2}. The output of the protocol is:
$$(\alpha_1, ..., \alpha_n) \xleftrightarrow{\text{(t, m)}} (q|Q, b_iG, H_0), \ i \in \{1, ..., t - 1\}.$$
The $\alpha$ values denote the secret key share belonging to $P_j$. They will be used to generate a partial signature for the key pair $(q, Q)$.
\\
\\
{\bf Signing algorithm}: Let $m$ denote the message to be signed. Suppose that a subset $H_1 \subseteq H_0$ wants to issue a signature. The members of $H_1$ proceed as follows:
\begin{enumerate}
	\item If $|H_1| < t$, aborts. Otherwise, the subset $H_1$ generates a random shared secret following again the protocol presented in the paragraph about the generation of a random shared secret. We denote the output as:
	$$(\beta_1, ..., \beta_n) \xleftrightarrow{\text{(t, m)}} (k|K, c_iG, H_2), \ i \in \{1, ..., t - 1\}.$$
	\item If $|H_2| < t$, aborts. Otherwise, each $P_i \in H_2$ reveals
	$$\gamma_i = \beta_i + \text{hash}(K \ || \ Q \ || \ m)\alpha_i.$$
	\item Each $P_i \in H_2$ verifies that:
	$$\gamma_lG = K + \sum_{j = 1}^{t - 1} c_jl^jG + \text{hash}(K \ || \ Q \ || \ m)\left(Q + \sum_{j = 1}^{t - 1}b_jl^jG\right), \ \forall l \in H_2.$$
	Let $H_3 = \{P_j \ | \ P_j \text{not detected to be cheating at step 3}\}$.
	\item If $|H_3| < t$, aborts. Otherwise each $P_i \in H_3$ selects an arbitrary subset $H_4 \subseteq H_3$ with $|H_4| = t$ and computes $\sigma$ satisfying $\sigma = k + \text{hash}(K \ || \ Q \ || \ m)q$, where:
	$$\sigma = \sum_{j \in H_4}\gamma_j\omega_j, \ \text{where} \ \omega_j = \prod_{h \in H_4, \ h \neq j}\frac{h}{h - j}.$$
	The signature is $(K, \sigma)$. To verify the signature, the same formula as in Schnorr scheme applies:
	$$\sigma G = K + \text{hash}(K \ || \ Q \ || \ m)Q.$$
\end{enumerate}
This concludes the presentation of the protocol. Nonetheless there are some formulas that deserves greater attention.
\begin{itemize}
	\item Checking formula at point 3: 
	$$\gamma_lG = (\beta_l + \text{hash}(K \ || \ Q \ || \ m)\alpha_l)G = \beta_lG + \text{hash}(K \ || \ Q \ || \ m)\alpha_lG = $$
	$$= \left(k + \sum_{j = 1}^{t - 1}c_jl^j\right)G + \text{hash}(K \ || \ Q \ || \ m)\left(q + \sum_{j = 1}^{t - 1}b_jl^j\right)G =$$
	$$= K + \sum_{j = 1}^{t - 1}c_jl^jG + \text{hash}(K \ || \ Q \ || \ m)\left(Q + \sum_{j = 1}^{t - 1}b_jl^jG\right).$$
	\item Formula used to compute $\sigma$: we defined $\gamma_i = \beta_i + \text{hash}(K \ || \ Q \ || \ m)\alpha_i, \ \forall i \in H_2$. In particular the equation holds for every $i \in H_4$, with $|H_4| = t$. The $\alpha$ and $\beta$ values are defined to be the pointwise evaluation of the sharing polynomials created during the two iterations of the Pedersen protocol for the generation of a random shared secret, that we denotes by $F_1(u)$ and $F_2(u)$. These polynomials have degree $t - 1$, so that we can define:
	$$F_3(u) = F_2(u) + \text{hash}(K \ || \ Q \ || \ m)F_1(u) \ \Longrightarrow $$
	$$\Longrightarrow \ F_3(0) = F_2(0) + \text{hash}(K \ || \ Q \ || \ m)F_1(0) = $$
	$$= k + \text{hash}(K \ || \ Q \ || \ m)q = \sigma.$$
	At this point we can apply the Lagrange's interpolation formula, since we know that $F_3(u)$ satisfies by construction $F_3(i) = \gamma_i$:
	$$F_3(u) = \sum_{j \in H_4}\gamma_j\omega_j(u), \ \text{where} \ \omega_j(u) = \prod_{h \in H_4, \ h \neq j}\frac{u - h}{j -h}.$$
	Thus, $\sigma$ can be directly computed as:
	$$\sigma = F_3(0) = \sum_{j \in H_4}\gamma_j\omega_j, \ \text{where} \ \omega_j = \prod_{h \in H_4, \ h \neq j}\frac{h}{h - j}.$$
\end{itemize}
Notice that the scheme is robust, meaning that a corrupt signer who does not follow the protocol will be detected. The validity of the partial signatures computed at step 2 is immediately tested at step 3.

\bigskip

\bigskip
\noindent
The scheme presented is complex and cumbersome, but all the work presented happens off-chain: the Bitcoin blockchain would see a standard transaction, indistinguishable from others. Nobody could tell that it required a threshold signature.

\bigskip

\bigskip

\section{Adaptor signatures}